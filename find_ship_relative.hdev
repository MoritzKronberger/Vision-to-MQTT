<?xml version="1.0" encoding="UTF-8"?>
<hdevelop file_version="1.2" halcon_version="22.11.0.0">
<procedure name="main">
<interface/>
<body>
<l>* dev_update_off ()</l>
<l>dev_get_window (WindowHandle)</l>
<c></c>
<c></c>
<c as_id="image_acquisition" as_name="Image Acquisition 01" as_grp="[1,1]" as_ord="1">* Image Acquisition 01: Code generated by Image Acquisition 01</c>
<l as_id="image_acquisition" as_name="Image Acquisition 01" as_grp="[1,1]" as_ord="2">* open_framegrabber ('DirectShow', 1, 1, 0, 0, 0, 0, 'default', 8, 'rgb', -1, 'false', 'default', '[1] HD Pro Webcam C920', 0, -1, AcqHandle)</l>
<c as_id="image_acquisition" as_name="Image Acquisition 01" as_grp="[1,1]" as_ord="1">* Image Acquisition 01: Code generated by Image Acquisition 01</c>
<c as_id="image_acquisition" as_name="Image Acquisition 01" as_grp="[1,1]" as_ord="1">* Image Acquisition 01: Code generated by Image Acquisition 01</c>
<l as_id="image_acquisition" as_name="Image Acquisition 01" as_grp="[1,1]" as_ord="2">open_framegrabber ('USB3Vision', 0, 0, 0, 0, 0, 0, 'progressive', -1, 'default', -1, 'false', 'default', '1409000BFC29_IDSImagingDevelopmentSystemsGmbH_U33250MLCHQ', 0, -1, AcqHandle)</l>
<c></c>
<c as_id="image_acquisition" as_name="Image Acquisition 01" as_grp="[1,2]" as_ord="1">* Image Acquisition 01: Attention: The parameterization may fail in case parameters need to</c>
<c as_id="image_acquisition" as_name="Image Acquisition 01" as_grp="[1,2]" as_ord="2">* Image Acquisition 01: be set in a specific order (e.g., image resolution vs. offset).</c>
<l as_id="image_acquisition" as_name="Image Acquisition 01" as_grp="[1,2]" as_ord="3">set_framegrabber_param (AcqHandle, 'ExposureTime', 10064.0)</l>
<l as_id="image_acquisition" as_name="Image Acquisition 01" as_grp="[2,1]" as_ord="1">grab_image_start (AcqHandle, -1)</l>
<c></c>
<c>* Bild verwenden </c>
<l>* FilePath := 'ImageGreen'</l>
<l>* open_framegrabber ('File', 0, 0, 0, 0, 0, 0, 'progressive', -1, 'default', -1, 'false', FilePath, FilePath, 0, -1, AcqHandle)</l>
<c></c>
<c></c>
<c>* create a calibratio model</c>
<l>read_cam_par ('calibration_offline_U3V/camera_internal.cal', CameraParam)</l>
<l>* create_caltab (3, 3, 0.03, 1, 1, 'light_on_dark', 'calplate.cpd', 'calplate.ps')</l>
<l>create_caltab (3, 3, 0.034, 1, 1, 'dark_on_light', 'calplate.cpd', 'calplate.ps')</l>
<c></c>
<c></c>
<l>create_calib_data ('calibration_object', 1, 1, CalibDataID)</l>
<l>set_calib_data_cam_param (CalibDataID, 0, [], CameraParam)</l>
<l>set_calib_data_calib_object (CalibDataID, 0, 'calplate.cpd')</l>
<l>get_calib_data (CalibDataID, 'camera', 0, 'pose_labels', PoseLabels)</l>
<c></c>
<l>minGrauwert := 100</l>
<l>maxGrauwert := 200</l>
<l>exposionStep := 100</l>
<l>boatSize := 150</l>
<c></c>
<l as_id="image_acquisition" as_name="Image Acquisition 01" as_grp="[2,2]" as_ord="1">while (true)</l>
<l as_id="image_acquisition" as_name="Image Acquisition 01" as_grp="[2,3]" as_ord="1">    grab_image_async (Image, AcqHandle, -1)</l>
<l>    ImageOut := Image</l>
<l>*     compose3 (Image, Image, Image, Image)</l>
<l>    access_channel (Image, ImageGreen, 2)</l>
<c>    </c>
<l>    gray_features (ImageGreen, ImageGreen, 'mean', Grauwert)</l>
<l>    get_framegrabber_param (AcqHandle, 'ExposureTime', CurrentExposureTime)</l>
<c>   </c>
<l>    if (Grauwert &gt; maxGrauwert)</l>
<l>        set_framegrabber_param (AcqHandle, 'ExposureTime', CurrentExposureTime - exposionStep)</l>
<l>    endif</l>
<c>    </c>
<l>    if (Grauwert &lt; minGrauwert)</l>
<l>        set_framegrabber_param (AcqHandle, 'ExposureTime', CurrentExposureTime + exposionStep)</l>
<l>    endif</l>
<c>    </c>
<c>    * results dict</c>
<l>    create_dict (DictHandle)</l>
<c>    </c>
<c as_id="image_acquisition" as_name="Image Acquisition 01" as_grp="[2,4]" as_ord="1">    * find object</c>
<l>    try</l>
<c>          </c>
<l>        find_calib_object (ImageGreen, CalibDataID, 0, 0, 0, [], [])</l>
<c>        </c>
<c>        * get results</c>
<l>        get_calib_data_observ_contours (Contours, CalibDataID, 'marks', 0, 0, 0)</l>
<l>        get_calib_data_observ_pose (CalibDataID, 0, 0, 0, ObjInCameraPose)</l>
<c>       </c>
<c>        </c>
<c>        * trash locate</c>
<l>        get_domain (Image, Domain)        </l>
<c>        </c>
<c>        * Mask at position of boat</c>
<l>        gen_region_contour_xld (Contours, Region, 'filled')</l>
<l>        union1 (Region, RegionUnion)</l>
<l>        shape_trans (RegionUnion, RegionTrans, 'rectangle2')</l>
<l>        dilation_circle (RegionTrans, RegionDilation, boatSize)</l>
<c>        * Remove mask from image</c>
<l>        difference (Domain, RegionDilation, RegionDifference1)</l>
<l>        reduce_domain (ImageGreen, RegionDifference1, ImageReduced)</l>
<c>  </c>
<l>        *binary_threshold (ImageGreen, Region, 'max_separability', 'light', UsedThreshold)</l>
<l>        *connection (Region, ConnectedRegions)</l>
<l>        *select_shape (ConnectedRegions, SelectedRegions, 'area', 'and', 13000, 14000)</l>
<l>        *area_center (SelectedRegions, Area, Row, Column)</l>
<l>        *gen_cross_contour_xld (Cross, Row, Column, 256, 0.785398)</l>
<c>         </c>
<c>        * Nur sehr weisse Bildbereiche</c>
<l>        threshold (ImageReduced, BrightPixels, 225, 255)</l>
<c>        * Verbindet Regionen</c>
<l>        connection (BrightPixels, Particles)</l>
<c>        * Nur Regionen die eine grössere Fläche als wie 200 Pixel haben</c>
<l>        select_shape (Particles, SelectedRegions, 'area', 'and', 200, 99999)</l>
<c>        * Vergrössert Regionen Kreisförmig damit zusammengehörende wieder 1 werden</c>
<l>        dilation_circle (SelectedRegions, RegionDilation1, 25.5)</l>
<c>        * Verbindet Regionen</c>
<l>        connection (BrightPixels, Particles)</l>
<c>        * Selektiert die grösste Region könnte auch so gelöst werden -&gt;</c>
<l>*         maxarea := max(Area)</l>
<l>*         select_shape (Particles, SelectedRegions, 'area', 'and', maxarea, 99999)</l>
<l>        select_shape_std (RegionDilation1, SelectedRegions1, 'max_area', 70)</l>
<l>        area_center (SelectedRegions1, Area, Row, Column)</l>
<l>        gen_cross_contour_xld (Cross, Row, Column, 256, 0.785398)</l>
<l>         dev_display (Cross)</l>
<c>        </c>
<c>        * transform point</c>
<l>        image_points_to_world_plane (CameraParam, ObjInCameraPose, Row, Column, 'm', X, Y)</l>
<c>       </c>
<c>        </c>
<c>        * set results</c>
<c>        * garbage</c>
<l>        set_dict_tuple(DictHandle, 'x_garbage', X)</l>
<l>        set_dict_tuple(DictHandle, 'y_garbage', Y)</l>
<c>        * boat</c>
<l>        set_dict_tuple(DictHandle, 'boat_visible', 1)</l>
<c> </c>
<c>        </c>
<c>        * display</c>
<l>        dev_update_off ()</l>
<l>        dev_display (ImageGreen)</l>
<l>        dev_set_line_width (3)</l>
<l>        dev_display (Contours)</l>
<l>        set_display_font (WindowHandle, 16, 'mono', 'true', 'false')</l>
<l>        disp_3d_coord_system (WindowHandle, CameraParam, ObjInCameraPose, 0.1)</l>
<l>        Text := PoseLabels +'   '+ ObjInCameraPose[0:5]</l>
<l>        dev_disp_text (Text, 'window', 'top', 'left', 'black', [], [])</l>
<c>        </c>
<c>        * create output image</c>
<l>        dump_window_image (ImageOut, WindowHandle)</l>
<l>    catch (Exception)</l>
<l>        dev_display (ImageGreen)</l>
<l>        dev_disp_text (Exception, 'window', 'top', 'left', 'black', [], [])</l>
<l>        set_dict_tuple(DictHandle, 'boat_visible', 0)</l>
<l>        dump_window_image (ImageOut, WindowHandle)</l>
<l>    endtry</l>
<c>    </c>
<c>    </c>
<c>    * write results to output file</c>
<l>    write_dict (DictHandle, 'test.json', [], [])    </l>
<l>    zoom_image_size (ImageOut, ImageOutZoom, 800, 600, 'constant')</l>
<l>    write_image (ImageOutZoom, 'jpeg', 0, 'capture')</l>
<l as_id="image_acquisition" as_name="Image Acquisition 01" as_grp="[3,1]" as_ord="1">endwhile</l>
<l as_id="image_acquisition" as_name="Image Acquisition 01" as_grp="[4,1]" as_ord="1">close_framegrabber (AcqHandle)</l>
</body>
<docu id="main">
<parameters/>
</docu>
</procedure>
</hdevelop>
